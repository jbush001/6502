#
# Copyright 2024 Jeff Bush
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import sys

# https://llx.com/Neil/a2/opcodes.html

table = [['IMPLIED', 'INVALID'] for _ in range(256)]

def set_inst(fmt, field_index, field_value):
    num_bits = fmt.count('?')
    for partial_index in range(2 ** num_bits):
        index_shift = partial_index
        table_index = 0
        for bit_index in range(8):
            table_index >>= 1
            digit = fmt[7 - bit_index]
            if digit == '?':
                table_index |= ((index_shift & 1) << 7)
                index_shift >>= 1
            elif digit == '1':
                table_index |= 0x80

        table[table_index][field_index] = field_value


def implied_inst(opcode, mnemonic):
    table[opcode][0] = 'IMPLIED'
    table[opcode][1] = mnemonic


def dump_table():
    print('struct m6502;')
    print()

    address_modes = set()
    for entry in table:
        address_modes.add(entry[0])

    instructions = set()
    for entry in table:
        instructions.add(entry[1])

    print('enum address_mode {')
    for entry in address_modes:
        print('    ' + entry + ',')

    print('};')
    print()

    for inst in instructions:
        print('void inst_' + inst + '(struct m6502 *proc, enum address_mode mode);')

    print()
    print('''struct instruction {
    enum address_mode mode;
    void (*func)(struct m6502 *proc, enum address_mode mode);
    const char *mnemonic;
};

const struct instruction INSTRUCTIONS[] = {''')

    for index, entry in enumerate(table):
        mnemonic = '???' if entry[1] == 'INVALID' else entry[1]
        line = f'    {{ {entry[0]}, inst_{entry[1]}, "{mnemonic}" }},'
        if index % 16 == 0:
            line += (' ' * (40 - len(line))) + '// ' + hex(index)
        print(line)

    print('};')

def main():
    print('// This file autogenerated by ' + sys.argv[0])

    # Group 1 instructions
    set_inst('???00001', 0, 'IND_ZERO_PAGE_X')
    set_inst('???00101', 0, 'ZERO_PAGE')
    set_inst('???01001', 0, 'IMMEDIATE')
    set_inst('???01101', 0, 'ABSOLUTE')
    set_inst('???10001', 0, 'IND_ZERO_PAGE_Y')
    set_inst('???10101', 0, 'ZERO_PAGE_X')
    set_inst('???11001', 0, 'ABSOLUTE_X')
    set_inst('???11101', 0, 'ABSOLUTE_Y')

    set_inst('000???01', 1, 'ORA')
    set_inst('001???01', 1, 'AND')
    set_inst('010???01', 1, 'EOR')
    set_inst('011???01', 1, 'ADC')
    set_inst('100???01', 1, 'STA')
    set_inst('101???01', 1, 'LDA')
    set_inst('110???01', 1, 'CMP')
    set_inst('111???01', 1, 'SBC')

    # Group 2 instructions
    set_inst('???00010', 0, 'IMMEDIATE')
    set_inst('???00110', 0, 'ZERO_PAGE')
    set_inst('???10110', 0, 'ACCUMULATOR')
    set_inst('???01110', 0, 'ABSOLUTE')
    set_inst('???10110', 0, 'ZERO_PAGE_X')
    set_inst('???11110', 0, 'ABSOLUTE_X')

    set_inst('000???10', 1, 'ASL')
    set_inst('001???10', 1, 'ROL')
    set_inst('010???10', 1, 'LSR')
    set_inst('011???10', 1, 'ROR')
    set_inst('100???10', 1, 'STX')
    set_inst('101???10', 1, 'LDX')
    set_inst('110???10', 1, 'DEC')
    set_inst('111???10', 1, 'INC')

    # Group 3 instructions
    set_inst('???00000', 0, 'IMMEDIATE')
    set_inst('???00100', 0, 'ZERO_PAGE')
    set_inst('???01100', 0, 'ABSOLUTE')
    set_inst('???10100', 0, 'ZERO_PAGE_X')
    set_inst('???11100', 0, 'ABSOLUTE_X')

    set_inst('001???00', 1, 'BIT')
    set_inst('100???00', 1, 'STY')
    set_inst('101???00', 1, 'LDY')
    set_inst('110???00', 1, 'CPY')
    set_inst('111???00', 1, 'CPX')

    set_inst('01?01100', 1, 'JMP')
    set_inst('01001100', 0, 'ABSOLUTE')
    set_inst('01101100', 0, 'INDIRECT')


    implied_inst(0x10, 'BPL')
    implied_inst(0x30, 'BMI')
    implied_inst(0x50, 'BVC')
    implied_inst(0x70, 'BVS')
    implied_inst(0x90, 'BCC')
    implied_inst(0xb0, 'BCS')
    implied_inst(0xd0, 'BNE')
    implied_inst(0xf0, 'BEQ')

    implied_inst(0x00, 'BRK')
    implied_inst(0x20, 'JSR')
    implied_inst(0x40, 'RTI')
    implied_inst(0x60, 'RTS')

    implied_inst(0x08, 'PHP')
    implied_inst(0x28, 'PLP')
    implied_inst(0x48, 'PHA')
    implied_inst(0x68, 'PLA')
    implied_inst(0x88, 'DEY')
    implied_inst(0xa8, 'TAY')
    implied_inst(0xc8, 'INY')
    implied_inst(0xe8, 'INX')
    implied_inst(0x18, 'CLC')
    implied_inst(0x38, 'SEC')
    implied_inst(0x58, 'CLI')
    implied_inst(0x78, 'SEI')
    implied_inst(0x98, 'TYA')
    implied_inst(0xb8, 'CLV')
    implied_inst(0xd8, 'CLD')
    implied_inst(0xf8, 'SED')
    implied_inst(0x8a, 'TXA')
    implied_inst(0x9a, 'TXS')
    implied_inst(0xaa, 'TAX')
    implied_inst(0xba, 'TSX')
    implied_inst(0xca, 'DEX')
    implied_inst(0xea, 'NOP')

    dump_table()

main()

