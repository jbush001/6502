#
# Copyright 2024 Jeff Bush
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# Build the instruction table, used for decoding instructions and
# disassembling.
#

import sys

ADDR_MODE = 0
MNENONIC = 1

table = [['IMPLIED', 'INVALID'] for _ in range(256)]

def inst_encoding(fmt, field_index, field_value):
    num_bits = fmt.count('?')
    for partial_index in range(2 ** num_bits):
        index_shift = partial_index
        table_index = 0
        for bit_index in range(8):
            table_index >>= 1
            digit = fmt[7 - bit_index]
            if digit == '?':
                table_index |= ((index_shift & 1) << 7)
                index_shift >>= 1
            elif digit == '1':
                table_index |= 0x80

        table[table_index][field_index] = field_value


def dump_table():
    print('struct m6502;')
    print()

    address_modes = set()
    for entry in table:
        address_modes.add(entry[0])

    instructions = set()
    for entry in table:
        instructions.add(entry[1])

    print('enum address_mode {')
    for entry in sorted(address_modes):
        print('    ' + entry + ',')

    print('};')
    print()

    for inst in sorted(instructions):
        print('void inst_' + inst + '(struct m6502 *proc, enum address_mode mode);')

    print()
    print('''struct instruction {
    enum address_mode mode;
    void (*func)(struct m6502 *proc, enum address_mode mode);
    const char *mnemonic;
};

const struct instruction INSTRUCTIONS[] = {''')

    for index, entry in enumerate(table):
        mnemonic = '???' if entry[1] == 'INVALID' else entry[1]
        line = f'    {{ {entry[0]}, inst_{entry[1]}, "{mnemonic}" }},'
        if index % 16 == 0:
            line += (' ' * (40 - len(line))) + '// ' + hex(index)
        print(line)

    print('};')

def main():
    print('// This file autogenerated by ' + sys.argv[0])

    # Group 1 instructions
    inst_encoding('???00001', ADDR_MODE, 'IND_ZERO_PAGE_X')
    inst_encoding('???00101', ADDR_MODE, 'ZERO_PAGE')
    inst_encoding('???01001', ADDR_MODE, 'IMMEDIATE')
    inst_encoding('???01101', ADDR_MODE, 'ABSOLUTE')
    inst_encoding('???10001', ADDR_MODE, 'IND_ZERO_PAGE_Y')
    inst_encoding('???10101', ADDR_MODE, 'ZERO_PAGE_X')
    inst_encoding('???11001', ADDR_MODE, 'ABSOLUTE_Y')
    inst_encoding('???11101', ADDR_MODE, 'ABSOLUTE_X')

    inst_encoding('000???01', MNENONIC, 'ORA')
    inst_encoding('001???01', MNENONIC, 'AND')
    inst_encoding('010???01', MNENONIC, 'EOR')
    inst_encoding('011???01', MNENONIC, 'ADC')
    inst_encoding('100???01', MNENONIC, 'STA')
    inst_encoding('101???01', MNENONIC, 'LDA')
    inst_encoding('110???01', MNENONIC, 'CMP')
    inst_encoding('111???01', MNENONIC, 'SBC')

    # Group 2 instructions
    inst_encoding('???00010', ADDR_MODE, 'IMMEDIATE')
    inst_encoding('???00110', ADDR_MODE, 'ZERO_PAGE')
    inst_encoding('???10110', ADDR_MODE, 'IMPLIED')
    inst_encoding('???01110', ADDR_MODE, 'ABSOLUTE')
    inst_encoding('???10110', ADDR_MODE, 'ZERO_PAGE_X')
    inst_encoding('???11110', ADDR_MODE, 'ABSOLUTE_X')

    inst_encoding('000???10', MNENONIC, 'ASL')
    inst_encoding('001???10', MNENONIC, 'ROL')
    inst_encoding('010???10', MNENONIC, 'LSR')
    inst_encoding('011???10', MNENONIC, 'ROR')
    inst_encoding('100???10', MNENONIC, 'STX')
    inst_encoding('101???10', MNENONIC, 'LDX')
    inst_encoding('110???10', MNENONIC, 'DEC')
    inst_encoding('111???10', MNENONIC, 'INC')

    # Group 3 instructions
    inst_encoding('???00000', ADDR_MODE, 'IMMEDIATE')
    inst_encoding('???00100', ADDR_MODE, 'ZERO_PAGE')
    inst_encoding('???01100', ADDR_MODE, 'ABSOLUTE')
    inst_encoding('???10100', ADDR_MODE, 'ZERO_PAGE_X')
    inst_encoding('???11100', ADDR_MODE, 'ABSOLUTE_X')

    inst_encoding('001???00', MNENONIC, 'BIT')
    inst_encoding('100???00', MNENONIC, 'STY')
    inst_encoding('101???00', MNENONIC, 'LDY')
    inst_encoding('110???00', MNENONIC, 'CPY')
    inst_encoding('111???00', MNENONIC, 'CPX')

    inst_encoding('01?01100', MNENONIC, 'JMP')
    inst_encoding('01001100', ADDR_MODE, 'ABSOLUTE')
    inst_encoding('01101100', ADDR_MODE, 'INDIRECT')

    # Implied instructions

    IMPLIED = [
        (0x10, 'BPL'),
        (0x30, 'BMI'),
        (0x50, 'BVC'),
        (0x70, 'BVS'),
        (0x90, 'BCC'),
        (0xb0, 'BCS'),
        (0xd0, 'BNE'),
        (0xf0, 'BEQ'),
        (0x00, 'BRK'),
        (0x20, 'JSR'),
        (0x40, 'RTI'),
        (0x60, 'RTS'),
        (0x08, 'PHP'),
        (0x28, 'PLP'),
        (0x48, 'PHA'),
        (0x68, 'PLA'),
        (0x88, 'DEY'),
        (0xa8, 'TAY'),
        (0xc8, 'INY'),
        (0xe8, 'INX'),
        (0x18, 'CLC'),
        (0x38, 'SEC'),
        (0x58, 'CLI'),
        (0x78, 'SEI'),
        (0x98, 'TYA'),
        (0xb8, 'CLV'),
        (0xd8, 'CLD'),
        (0xf8, 'SED'),
        (0x8a, 'TXA'),
        (0x9a, 'TXS'),
        (0xaa, 'TAX'),
        (0xba, 'TSX'),
        (0xca, 'DEX'),
        (0xea, 'NOP')
    ]

    for opcode, mnemonic in IMPLIED:
        table[opcode][0] = 'IMPLIED'
        table[opcode][1] = mnemonic

    dump_table()

main()

